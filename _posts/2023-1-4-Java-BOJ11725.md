---
layout: post
title: Java-BOJ 11725
subtitle: "자바로 코딩테스트를 준비합니다"
type: "CODING_TEST"
published: true
---

자바로 코딩테스트를 준비합니다

# DFS

_Depth-First-Search_

깊이 우선 탐색은 연결된 노드를 따라 게속 방문을 한 후에 

더 이상 연결된 노드가 없을 때 그 전 노드로 되돌아가는 것을 반복하는 탐색입니다

# BOJ 11725

노드들의 연결 상태를 입력받고 각 노드의 부모 노드를 출력하는 문제입니다

최대 100,000개의 노드를 입력할 수 있는데,

모든 노드의 연결 상태를 2차원 배열로 저장하면 100,000 * 100,000 = 100억개의 메모리가 필요합니다

따라서 (1, 6) 의 연결 상태를 2차원 배열에 array[1].add(6) 방식으로 저장하면

위 문제를 해결할 수 있습니다

```java
    ArrayList<ArrayList<Integer>> tree = new ArrayList<>();
    for (int i = 0; i < n + 1; i++) {
        tree.add(new ArrayList<>());
    }

    for (int i = 0; i < n - 1; i++) {
        StringTokenizer st = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(st.nextToken());
        int b = Integer.parseInt(st.nextToken());

        tree.get(a).add(b);
        tree.get(b).add(a);
    }
```

연결 상태를 모두 저장했다면 부모 노드를 저장해야 합니다

DFS 방법을 통해 부모 노드를 저장할 수 있습니다

```java
	{
		...

        int[] parentsNode = new int[n + 1];

        dfs(tree, parentsNode, 1, 0);
		
		...

	}

    public static void dfs(ArrayList<ArrayList<Integer>> tree, int[] parentsNode, int nodeIndex, int parentsIndex) {
        parentsNode[nodeIndex] = parentsIndex;

        for (int index : tree.get(nodeIndex)) {
            if (index != parentsIndex)
                dfs(tree, parentsNode, index, nodeIndex);
        }
    }
```

dfs()의 매개변수는 순서대로

1. `tree`: 연결 상태가 저장된 2차원 배열
2. `parentsNode`: 부모 노드를 저장할 배열
3. `nodeIndex`: 방문할 노드
4. `parentsIndex`: 이전에 방문한 노드 번호(부모노드)

문제에서 주어진 루트 노드 1 부터 DFS를 시작합니다

`tree.get(nodeIndex)` 를 통해 노드 1 에 연결된 노드들을 불러옵니다

1 과 연결된 노드와 부모 노드가 같은지 확인합니다

이 조건문에서 같다는 것은 서로의 부모 노드가 같다는 것을 의미하며

서로 연결되어 있다 즉, 더이상 내려갈 수 없음을 의미합니다

해당 조건이 없다면 DFS는 게속 돌게 되므로 종료 조건이 필수적으로 필요합니다


* 단순 DFS java로 구현


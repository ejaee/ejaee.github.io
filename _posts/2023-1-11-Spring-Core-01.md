---
layout: post
title: (Spring Core) 비즈니스 요구사항과 설계 과정  
subtitle: "김영한 Spring Core 강의 내용을 정리합니다"
type: "TIL"
published: true
---

섹션 2. 스프링 핵심 원리 이해1 강의에 대한 내용입니다

# 기능 요구사항

### **회원**

- 회원을 가입하고 조회할 수 있다
- 회원은 일반과 vip 두 가지 등급이 있다
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다(미확정)

### **주문과 할인 정책**

- 회원을 상품을 주문할 수 있다
- 회원 등급에 따라 할인 정책을 적용할 수 있다
- 할인 정책은 모든 VIP는 1000원을 할인해준느 고정 금액 할인을 적용해달라
(나중에 변경될 수 있다)
- 할인 정책은 변경 가능성이 높다 최악의 경우 할인을 적용하지 않을 수도 있다(미확정)

> 미확정 되는 부분이 있더라도 객체 지향적으로 설계한다면 문제가 없습니다

설계 순서는 순수 자바 -> 스프링으로 발전 하는 방향으로 진행됩니다

# 회원 도메인 설계

### **회원**

- 회원을 가입하고 조회할 수 있다
- 회원은 일반과 vip 두 가지 등급이 있다
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스텀과 연동할 수 있다(미확정)

# 회원 도메인 협력 관계

기획자도 볼 수 있는 그림입니다

도메인에 대한 큰 그림을 그립니다

![_config.yml]()

1. 클라이언트는 회원 서비스에게 회원가입, 회원조회 기능을 요청합니다
2. 회원 서비스는 회원 저장소에게 저장 요청 또는 저장 목록을 요청합니다
3. 회원 저장소는 아직 어떤 방식의 저장소로 저장될지 정해지지 않았고 바뀔 수 있습니다
    - 인터페이스로 설계합니다

# 회원 클래스 다이어그램

개발자가 위 그림을 구체화해서 클래스 다이어그램을 만듭니다

![_config.yml]()

1. 회원 서비스와 회원 저장소는 확장 가능성을 열어두기 위해 인터페이스로 설계합니다

# 회원 객체 다이어그램

실제 서버를 실행하고 클라이언트가 실제 사용하는 (동적)객체들을 보여줍니다

객체간의 참조가 어떻게 이루어지는지 보여줍니다

![_config.yml]()

- 회원서비스 : MemberServiceImpl

# 회원 도메인 개발

회원 클래스 다이어그램을 참고해 만들어 나갑니다

### 회원 엔티티

- [Entity?]()

```java

```

### 회원 등급

```java

```

상수 값을 보통 Enum 을 통해 관리합니다

> 회원 등급을 Enum 으로 관리하는 이유는?
> 나는 Enum에 대해 얼마나 알고 있는가?
- [Enum?]()

### 회원 저장소

인터페이스(MemberRepo)를 만들고 그에대한 구현 class(MemoryMemberRepo)를 만듭니다

### 회원 서비스

요구 기능인 회원 가입과 회원 조회 기능을 만들어야 합니다

마찬가지로 인터페이스(MemberService)를 먼저 만들고 그에대한 구현 class(MemberServiceImpl)를 만듭니다

참고로 구현 클래스가 하나인 경우 통상 `Impl` 을 붙입니다

### App

잘 구현이 되었는지 확인해봅니다

MemberApp을 만들어 실행해봅니다

1. 서비스를 생성하고
2. 멤버 객체를 생성한 후 
3. 멤서 서비스의 회원 가입 메서드에 멤버를 넣습니다
4. 이후 회원 조회 메서드를 통해 해당 멤버가 존재하는지 확인합니다

이러한 방식을 Junit의 Test를 통해 단순화할 수 있습니다

# 회원 도메인 설계의 문제점

여기까지 진행한 코드에 문제점이 있습니다

다른 저장소로 변경할 때 OCP의 원칙이 잘 준수되지 않습니다

DIP의 원칙 또한 잘 준수되지 않습니다

의존관계가 인터페이스에만 의존해야하는데 구현까지 모두 의존하는 문제가 있습니다

```java
    pivate final MemberRepository memberRepository
    // 추상에 의존
    = new MemoryMemberRepository();
    // 구현까지 의존
```

# 주문과 할인 도메인 설계

### **주문과 할인 정책**
- 회원을 상품을 주문할 수 있다
- 회원 등급에 따라 할인 정책을 적용할 수 있다
- 할인 정책은 모든 VIP는 1000원을 할인해준느 고정 금액 할인을 적용해달라
(나중에 변경될 수 있다)
- 할인 정책은 변경 가능성이 높다 최악의 경우 할인을 적용하지 않을 수도 있다(미확정)

`클라이언트`는 **주문을 생성**을 요청합니다

> 클라이언트는 main 문/ Controller 에 해당됩니다

`주문 서비스`는 **주문 생성의 역할**을 합니다

회원 등급이 필요하기 때문에 먼저 `회원 저장소`에서 **회원을 조회**해서 **등급을 확인**해야 합니다

**회원 등급을 확인**하고 `할인 정책` 에 **할인 금액을 물어봅니다**

`할인 정책`에게 **할인 금액을 반환**받습니다

`주문 서비스`는 최종적으로 할인 금액이 적용된 **주문 결과**를 `클라이언트`에게 반환합니다

이를 다시 정리하자면,

1. 주문 생성
2. 회원 조회
3. 할인 적용
4. 주문 결과 반환

### 주문 도메인 전체

![_config.yml]()

역할과 구현을 분리했기 때문에 구현 객체를 조립할 수 있게 설계할 수 있습니다

### 할인 정책

인터페이스 설계 후 구현을 진행합니다

할인 정책 객체의 행동에 맞게 할인 메서드를 만들어줍니다

구현 객체는 반환 값으로 할인 금액을 반환해야 합니다

생성자의 매개변수로

1. 등급을 확인을 위한 Member member
2. 원가인 int price

두 가지를 받고 있습니다

> 현재 쓰이지 않고 있는데 2번을 받는 이유는 무엇일까요? (주문과 할인 도메인 개발 2:24)
> 미래 확장성?

### 주문

멤버 아이디와, 상품관련 정보들, 할인 금액이 저장되는 객체가 필요합니다

주문 객체 내에서 원가와 할인금액이 함께 존재하고 할인이 적용된 금액을 반환하는 메서드를 만듭니다

다른 class를 끌어다 오는것이 아니라

```java
    public int calculatePrice(){
        return itemprice - discountPrice;
    }
```

를 통해 구현합니다

### 주문 서비스

주문을 만드는 역할을 합니다

반홚값으로 위에서 만든 주문 객체를 반환해야 할겁니다

마찬가지로 추상 -> 구현 순으로 설계합니다

### 주문 서비스 구현 class

주문을 만들어야하는 순서는 다음과 같습니다

1. 멤버를 찾는다(memberRepository)
2. 할인금액을 구한다(discountPolicy)

멤버를 찾는 class 와 할인 금액을 구하는 class 가 각각 구현되어 있으므로

이를 생성만 해준다면 주문 서비스 구현 class에서는 가져다가 쓰기만 하면 됩니다

멤버 찾는 방식이 달라지거나 할인 정책이 달라지더라도 해당 class 를 수정할 필요가 없습니다

단일 책임의 원칙이 지켜진 것 입니다

주문과 주문 서비스가 어떻게 구분되었는지를 잘 들여다 볼 필요가 있어 보입니다

주문 객체는 멤버 아이디와, 상품이름, 상품가격, 할인가격 을 받아 그 값들을 저장하기만 합니다

또한 저장된 값을 통해 할인 금액을 반환하는 행동을 하기도 합니다

할인 금액을 구하는 행동은 주문 객체에서 이루어지지 않습니다

주문 서비스에서 할인 금액이 구해집니다

주문 서비스에서 할인 금액을 직접 계산하지 않습니다

우리는 할인 정책 class를 만들었고 해당 클래스에서 금액을 계산하게 됩니다

### App

정상적으로 작동하는지 실행해봅니다

멤버 서비스를 통해 회원 가입을 진행하고

주문 서비스를 통해 주문합니다

만들어진 주문 객체를 확인해봅니다

---

이 글은 김영한님 Spring Core 의 섹션2에 대한 글입니다

요구 사항을 통해 기능 목록을 만들고

단일 책임을 가지기 위한 설계 순서를 중점적으로 공부했습니다

- 설계를 진행하고 그에 맞게 구현하는 순서를 확인합니다
- 추상 인터페이스를 먼저 선언하고 구현함으로써 확장 가능성이 보장되었습니다
- 코드에서 OCP 와 DIP 원칙을 지키지 않는 포인트를 인지해야 합니다